#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Nov 22 15:41:57 2012 by generateDS.py version 2.7c.
#

import sys
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

class GeneratedsSuper(object):
    def gds_format_string(self, input_data, input_name=''):
        return input_data
    def gds_validate_string(self, input_data, node, input_name=''):
        return input_data
    def gds_format_integer(self, input_data, input_name=''):
        return '%d' % input_data
    def gds_validate_integer(self, input_data, node, input_name=''):
        return input_data
    def gds_format_integer_list(self, input_data, input_name=''):
        return '%s' % input_data
    def gds_validate_integer_list(self, input_data, node, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                fvalue = float(value)
            except (TypeError, ValueError), exp:
                raise_parse_error(node, 'Requires sequence of integers')
        return input_data
    def gds_format_float(self, input_data, input_name=''):
        return '%f' % input_data
    def gds_validate_float(self, input_data, node, input_name=''):
        return input_data
    def gds_format_float_list(self, input_data, input_name=''):
        return '%s' % input_data
    def gds_validate_float_list(self, input_data, node, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                fvalue = float(value)
            except (TypeError, ValueError), exp:
                raise_parse_error(node, 'Requires sequence of floats')
        return input_data
    def gds_format_double(self, input_data, input_name=''):
        return '%e' % input_data
    def gds_validate_double(self, input_data, node, input_name=''):
        return input_data
    def gds_format_double_list(self, input_data, input_name=''):
        return '%s' % input_data
    def gds_validate_double_list(self, input_data, node, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                fvalue = float(value)
            except (TypeError, ValueError), exp:
                raise_parse_error(node, 'Requires sequence of doubles')
        return input_data
    def gds_format_boolean(self, input_data, input_name=''):
        return '%s' % input_data
    def gds_validate_boolean(self, input_data, node, input_name=''):
        return input_data
    def gds_format_boolean_list(self, input_data, input_name=''):
        return '%s' % input_data
    def gds_validate_boolean_list(self, input_data, node, input_name=''):
        values = input_data.split()
        for value in values:
            if value not in ('true', '1', 'false', '0', ):
                raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
        return input_data
    def gds_str_lower(self, instring):
        return instring.lower()
    def get_path_(self, node):
        path_list = []
        self.get_path_list_(node, path_list)
        path_list.reverse()
        path = '/'.join(path_list)
        return path
    Tag_strip_pattern_ = re_.compile(r'\{.*\}')
    def get_path_list_(self, node, path_list):
        if node is None:
            return
        tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
        if tag:
            path_list.append(tag)
        self.get_path_list_(node.getparent(), path_list)
    def get_class_obj_(self, node, default_class=None):
        class_obj1 = default_class
        if 'xsi' in node.nsmap:
            classname = node.get('{%s}type' % node.nsmap['xsi'])
            if classname is not None:
                names = classname.split(':')
                if len(names) == 2:
                    classname = names[1]
                class_obj2 = globals().get(classname)
                if class_obj2 is not None:
                    class_obj1 = class_obj2
        return class_obj1
    def gds_build_any(self, node, type_name=None):
        return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class QueryNsaRequestType(GeneratedsSuper):
    """Type definition for the queryNSA request operation. Elements:
    requestType - This element is an enumeration specifying either a
    "Summary" or "Detailed" discovery query. If "Summary" is
    specified then only the base NSA attributes are provided in the
    response with no service element. The "Detailed" discovery query
    returns the base NSA attributes and detailed services list.
    filter - A simple filter allowing requester to specify nsaId and
    serviceType strings to match againsts discovery results."""
    subclass = None
    superclass = None
    def __init__(self, requestType='Detailed', filter=None):
        self.requestType = requestType
        self.filter = filter
    def factory(*args_, **kwargs_):
        if QueryNsaRequestType.subclass:
            return QueryNsaRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryNsaRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestType(self): return self.requestType
    def set_requestType(self, requestType): self.requestType = requestType
    def validate_RequestType(self, value):
        # Validate type RequestType, a restriction on xsd:string.
        pass
    def get_filter(self): return self.filter
    def set_filter(self, filter): self.filter = filter
    def export(self, outfile, level, namespace_='tns:', name_='QueryNsaRequestType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryNsaRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='QueryNsaRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='QueryNsaRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.requestType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestType>%s</%srequestType>%s' % (namespace_, self.gds_format_string(quote_xml(self.requestType).encode(ExternalEncoding), input_name='requestType'), namespace_, eol_))
        if self.filter is not None:
            self.filter.export(outfile, level, namespace_, name_='filter', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.requestType is not None or
            self.filter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryNsaRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.requestType is not None:
            showIndent(outfile, level)
            outfile.write('requestType=%s,\n' % quote_python(self.requestType).encode(ExternalEncoding))
        if self.filter is not None:
            showIndent(outfile, level)
            outfile.write('filter=model_.FilterType(\n')
            self.filter.exportLiteral(outfile, level, name_='filter')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'requestType':
            requestType_ = child_.text
            requestType_ = self.gds_validate_string(requestType_, node, 'requestType')
            self.requestType = requestType_
            self.validate_RequestType(self.requestType)    # validate type RequestType
        elif nodeName_ == 'filter':
            obj_ = FilterType.factory()
            obj_.build(child_)
            self.set_filter(obj_)
# end class QueryNsaRequestType


class QueryNsaResponseType(GeneratedsSuper):
    """Type definition for the queryNSA response operation. Elements:
    discovery - the list of discovered NSA matching the query
    criteria."""
    subclass = None
    superclass = None
    def __init__(self, discovery=None):
        self.discovery = discovery
    def factory(*args_, **kwargs_):
        if QueryNsaResponseType.subclass:
            return QueryNsaResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryNsaResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_discovery(self): return self.discovery
    def set_discovery(self, discovery): self.discovery = discovery
    def export(self, outfile, level, namespace_='tns:', name_='QueryNsaResponseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryNsaResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='QueryNsaResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='QueryNsaResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.discovery is not None:
            self.discovery.export(outfile, level, namespace_, name_='discovery', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.discovery is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryNsaResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.discovery is not None:
            showIndent(outfile, level)
            outfile.write('discovery=model_.discovery(\n')
            self.discovery.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'discovery':
            obj_ = discovery.factory()
            obj_.build(child_)
            self.set_discovery(obj_)
# end class QueryNsaResponseType


class discovery(GeneratedsSuper):
    """Element definition for the queryNsaResponse message containing the
    discovered NSA and services/interfaces matching the query
    filter."""
    subclass = None
    superclass = None
    def __init__(self, nsa=None):
        if nsa is None:
            self.nsa = []
        else:
            self.nsa = nsa
    def factory(*args_, **kwargs_):
        if discovery.subclass:
            return discovery.subclass(*args_, **kwargs_)
        else:
            return discovery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nsa(self): return self.nsa
    def set_nsa(self, nsa): self.nsa = nsa
    def add_nsa(self, value): self.nsa.append(value)
    def insert_nsa(self, index, value): self.nsa[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='discovery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='discovery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='discovery'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='discovery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nsa_ in self.nsa:
            nsa_.export(outfile, level, namespace_, name_='nsa', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.nsa
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='discovery'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('nsa=[\n')
        level += 1
        for nsa_ in self.nsa:
            showIndent(outfile, level)
            outfile.write('model_.NsaDiscoveryType(\n')
            nsa_.exportLiteral(outfile, level, name_='NsaDiscoveryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nsa':
            obj_ = NsaDiscoveryType.factory()
            obj_.build(child_)
            self.nsa.append(obj_)
# end class discovery


class NsaDiscoveryType(GeneratedsSuper):
    """Type definition for the result of an interface discovery operation.
    The result will be zero or more services matching the request
    types. Attributes: nsaId - Identifier of the NSA this entry
    represents. softwareVersion - Software type and version of this
    NSA. startTime - The time at which this NSA started providing
    uninterupted service. currentTime - The current system time of
    the NSA. Elements: services - The list of services supported by
    the NSA."""
    subclass = None
    superclass = None
    def __init__(self, softwareVersion=None, nsaId=None, startTime=None, currentTime=None, services=None):
        self.softwareVersion = _cast(None, softwareVersion)
        self.nsaId = _cast(None, nsaId)
        self.startTime = _cast(None, startTime)
        self.currentTime = _cast(None, currentTime)
        self.services = services
    def factory(*args_, **kwargs_):
        if NsaDiscoveryType.subclass:
            return NsaDiscoveryType.subclass(*args_, **kwargs_)
        else:
            return NsaDiscoveryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_services(self): return self.services
    def set_services(self, services): self.services = services
    def get_softwareVersion(self): return self.softwareVersion
    def set_softwareVersion(self, softwareVersion): self.softwareVersion = softwareVersion
    def get_nsaId(self): return self.nsaId
    def set_nsaId(self, nsaId): self.nsaId = nsaId
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_currentTime(self): return self.currentTime
    def set_currentTime(self, currentTime): self.currentTime = currentTime
    def export(self, outfile, level, namespace_='tns:', name_='NsaDiscoveryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NsaDiscoveryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='NsaDiscoveryType'):
        if self.softwareVersion is not None and 'softwareVersion' not in already_processed:
            already_processed.append('softwareVersion')
            outfile.write(' softwareVersion=%s' % (self.gds_format_string(quote_attrib(self.softwareVersion).encode(ExternalEncoding), input_name='softwareVersion'), ))
        if self.nsaId is not None and 'nsaId' not in already_processed:
            already_processed.append('nsaId')
            outfile.write(' nsaId=%s' % (quote_attrib(self.nsaId), ))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            outfile.write(' startTime=%s' % (quote_attrib(self.startTime), ))
        if self.currentTime is not None and 'currentTime' not in already_processed:
            already_processed.append('currentTime')
            outfile.write(' currentTime=%s' % (quote_attrib(self.currentTime), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='NsaDiscoveryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.services is not None:
            self.services.export(outfile, level, namespace_, name_='services', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.services is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NsaDiscoveryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.softwareVersion is not None and 'softwareVersion' not in already_processed:
            already_processed.append('softwareVersion')
            showIndent(outfile, level)
            outfile.write('softwareVersion = "%s",\n' % (self.softwareVersion,))
        if self.nsaId is not None and 'nsaId' not in already_processed:
            already_processed.append('nsaId')
            showIndent(outfile, level)
            outfile.write('nsaId = %s,\n' % (self.nsaId,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            showIndent(outfile, level)
            outfile.write('startTime = %s,\n' % (self.startTime,))
        if self.currentTime is not None and 'currentTime' not in already_processed:
            already_processed.append('currentTime')
            showIndent(outfile, level)
            outfile.write('currentTime = %s,\n' % (self.currentTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.services is not None:
            showIndent(outfile, level)
            outfile.write('services=model_.ServicesType(\n')
            self.services.exportLiteral(outfile, level, name_='services')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('softwareVersion', node)
        if value is not None and 'softwareVersion' not in already_processed:
            already_processed.append('softwareVersion')
            self.softwareVersion = value
        value = find_attr_value_('nsaId', node)
        if value is not None and 'nsaId' not in already_processed:
            already_processed.append('nsaId')
            self.nsaId = value
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            self.startTime = value
        value = find_attr_value_('currentTime', node)
        if value is not None and 'currentTime' not in already_processed:
            already_processed.append('currentTime')
            self.currentTime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'services':
            obj_ = ServicesType.factory()
            obj_.build(child_)
            self.set_services(obj_)
# end class NsaDiscoveryType


class ServicesType(GeneratedsSuper):
    """Type definition for the set of zero or more supported services on
    the NSA. Elements: service - A specific service supported by the
    NSA."""
    subclass = None
    superclass = None
    def __init__(self, service=None):
        if service is None:
            self.service = []
        else:
            self.service = service
    def factory(*args_, **kwargs_):
        if ServicesType.subclass:
            return ServicesType.subclass(*args_, **kwargs_)
        else:
            return ServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def add_service(self, value): self.service.append(value)
    def insert_service(self, index, value): self.service[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='ServicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='ServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='ServicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for service_ in self.service:
            service_.export(outfile, level, namespace_, name_='service', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('service=[\n')
        level += 1
        for service_ in self.service:
            showIndent(outfile, level)
            outfile.write('model_.ServiceType(\n')
            service_.exportLiteral(outfile, level, name_='ServiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service':
            obj_ = ServiceType.factory()
            obj_.build(child_)
            self.service.append(obj_)
# end class ServicesType


class ServiceType(GeneratedsSuper):
    """Type definition for a service. A service may consist of zero or more
    versions. Elements: description - A user friendly description of
    the service. versions - Versions of the service supported by the
    NSA. any - Provides a flexible mechanism allowing additional
    elements to be provided in the discovery message. Use of this
    element field is beyond the current scope of this NSI
    specification, but may be used in the future to extend the
    existing protocol without requiring a schema change.
    Additionally, the field can be used between peered NSA to
    provide additional context not covered in the existing
    specification, however, this is left up to specific peering
    agreements. Attributes: type - A string identify the service
    type such as "ConnectionService", "TopologyService", or
    "DiscoveryService". anyAttribute - Provides a flexible mechanism
    allowing additional attributes in the discovery message exchange
    between two peered NSA. Use of this attribute field is beyond
    the current scope of this NSI specification, but may be used in
    the future to extend the existing protocol without requiring a
    schema change. Additionally, the field can be used between
    peered NSA to provide additional context not covered in the
    existing specification, however, this is left up to specific
    peering agreements."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, description=None, versions=None, anytypeobjs_=None):
        self.type_ = _cast(None, type_)
        self.description = description
        self.versions = versions
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ServiceType.subclass:
            return ServiceType.subclass(*args_, **kwargs_)
        else:
            return ServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_versions(self): return self.versions
    def set_versions(self, versions): self.versions = versions
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='tns:', name_='ServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='ServiceType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='ServiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.versions is not None:
            self.versions.export(outfile, level, namespace_, name_='versions', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.description is not None or
            self.versions is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.versions is not None:
            showIndent(outfile, level)
            outfile.write('versions=model_.VersionsType(\n')
            self.versions.exportLiteral(outfile, level, name_='versions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'versions':
            obj_ = VersionsType.factory()
            obj_.build(child_)
            self.set_versions(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'ServiceType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class ServiceType


class VersionsType(GeneratedsSuper):
    """Type definition for the set of zero or more supported versions of
    the service. Elements: version - A specific version supported by
    the service."""
    subclass = None
    superclass = None
    def __init__(self, version=None):
        if version is None:
            self.version = []
        else:
            self.version = version
    def factory(*args_, **kwargs_):
        if VersionsType.subclass:
            return VersionsType.subclass(*args_, **kwargs_)
        else:
            return VersionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def add_version(self, value): self.version.append(value)
    def insert_version(self, index, value): self.version[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='VersionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='VersionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='VersionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for version_ in self.version:
            version_.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.version
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VersionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('version=[\n')
        level += 1
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('model_.VersionType(\n')
            version_.exportLiteral(outfile, level, name_='VersionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version.append(obj_)
# end class VersionsType


class VersionType(GeneratedsSuper):
    """Type definition for a service. A service may consist of zero or more
    versions. Elements: capabilities - a list of capabilities
    supported by the NSA for this version of the service. any -
    Provides a flexible mechanism allowing additional elements to be
    provided in the discovery message. Use of this element field is
    beyond the current scope of this NSI specification, but may be
    used in the future to extend the existing protocol without
    requiring a schema change. Additionally, the field can be used
    between peered NSA to provide additional context not covered in
    the existing specification, however, this is left up to specific
    peering agreements. Attributes: name - A friendly name for the
    service version such as "NSI-CS-1.SC-Provider", "NSI-
    CS-2.0-Provider", or "NSI-Topology-1.0-Provider". version - The
    URL uniquely identifying the service version. For example, the
    following URL identify NSI-CS-1.SC-Provider" and "NSI-
    CS-2.0-Provider" respectively:
    http://schemas.ogf.org/nsi/2011/10/connection/provider
    http://schemas.ogf.org/nsi/2012/03/connection/provider endpoint
    - An optional URL representing the SOAP endpoint on which this
    version of the service is available. If this is not a SOAP based
    interface then the attribute is not provided. wsdl - An optional
    URL providing remote download of the WSDL definition if the
    interface is SOAP based. url - An optional URL providing a link
    to data relating to the service. This can be used by a service
    providing access to a downloadable document. anyAttribute -
    Provides a flexible mechanism allowing additional attributes in
    the discovery message exchange between two peered NSA. Use of
    this attribute field is beyond the current scope of this NSI
    specification, but may be used in the future to extend the
    existing protocol without requiring a schema change.
    Additionally, the field can be used between peered NSA to
    provide additional context not covered in the existing
    specification, however, this is left up to specific peering
    agreements."""
    subclass = None
    superclass = None
    def __init__(self, url=None, wsdl=None, version=None, endpoint=None, name=None, capabilities=None, anytypeobjs_=None):
        self.url = _cast(None, url)
        self.wsdl = _cast(None, wsdl)
        self.version = _cast(None, version)
        self.endpoint = _cast(None, endpoint)
        self.name = _cast(None, name)
        self.capabilities = capabilities
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VersionType.subclass:
            return VersionType.subclass(*args_, **kwargs_)
        else:
            return VersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_capabilities(self): return self.capabilities
    def set_capabilities(self, capabilities): self.capabilities = capabilities
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_wsdl(self): return self.wsdl
    def set_wsdl(self, wsdl): self.wsdl = wsdl
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_endpoint(self): return self.endpoint
    def set_endpoint(self, endpoint): self.endpoint = endpoint
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='tns:', name_='VersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='VersionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.wsdl is not None and 'wsdl' not in already_processed:
            already_processed.append('wsdl')
            outfile.write(' wsdl=%s' % (self.gds_format_string(quote_attrib(self.wsdl).encode(ExternalEncoding), input_name='wsdl'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.endpoint is not None and 'endpoint' not in already_processed:
            already_processed.append('endpoint')
            outfile.write(' endpoint=%s' % (self.gds_format_string(quote_attrib(self.endpoint).encode(ExternalEncoding), input_name='endpoint'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='VersionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.capabilities is not None:
            self.capabilities.export(outfile, level, namespace_, name_='capabilities', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.capabilities is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VersionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            showIndent(outfile, level)
            outfile.write('url = "%s",\n' % (self.url,))
        if self.wsdl is not None and 'wsdl' not in already_processed:
            already_processed.append('wsdl')
            showIndent(outfile, level)
            outfile.write('wsdl = "%s",\n' % (self.wsdl,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.endpoint is not None and 'endpoint' not in already_processed:
            already_processed.append('endpoint')
            showIndent(outfile, level)
            outfile.write('endpoint = "%s",\n' % (self.endpoint,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.capabilities is not None:
            showIndent(outfile, level)
            outfile.write('capabilities=model_.CapabilitiesType(\n')
            self.capabilities.exportLiteral(outfile, level, name_='capabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.append('url')
            self.url = value
        value = find_attr_value_('wsdl', node)
        if value is not None and 'wsdl' not in already_processed:
            already_processed.append('wsdl')
            self.wsdl = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('endpoint', node)
        if value is not None and 'endpoint' not in already_processed:
            already_processed.append('endpoint')
            self.endpoint = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'capabilities':
            obj_ = CapabilitiesType.factory()
            obj_.build(child_)
            self.set_capabilities(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'VersionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class VersionType


class CapabilitiesType(GeneratedsSuper):
    """Type definition for the set of zero or more capabilities supported
    by the version of the service. Elements: capability - A specific
    capability supported by the version of the service."""
    subclass = None
    superclass = None
    def __init__(self, capability=None):
        if capability is None:
            self.capability = []
        else:
            self.capability = capability
    def factory(*args_, **kwargs_):
        if CapabilitiesType.subclass:
            return CapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return CapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_capability(self): return self.capability
    def set_capability(self, capability): self.capability = capability
    def add_capability(self, value): self.capability.append(value)
    def insert_capability(self, index, value): self.capability[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='CapabilitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='CapabilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='CapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for capability_ in self.capability:
            capability_.export(outfile, level, namespace_, name_='capability', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.capability
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CapabilitiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('capability=[\n')
        level += 1
        for capability_ in self.capability:
            showIndent(outfile, level)
            outfile.write('model_.TypeValuePairType(\n')
            capability_.exportLiteral(outfile, level, name_='TypeValuePairType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'capability':
            obj_ = TypeValuePairType.factory()
            obj_.build(child_)
            self.capability.append(obj_)
# end class CapabilitiesType


class FilterType(GeneratedsSuper):
    """This type definition provides a basic filter for scoping discovery
    results. For the NSA specified in this filter (nsaId) the
    requested service types (serviceType) will be returned"""
    subclass = None
    superclass = None
    def __init__(self, nsaId=None, serviceType=None):
        if nsaId is None:
            self.nsaId = []
        else:
            self.nsaId = nsaId
        if serviceType is None:
            self.serviceType = []
        else:
            self.serviceType = serviceType
    def factory(*args_, **kwargs_):
        if FilterType.subclass:
            return FilterType.subclass(*args_, **kwargs_)
        else:
            return FilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nsaId(self): return self.nsaId
    def set_nsaId(self, nsaId): self.nsaId = nsaId
    def add_nsaId(self, value): self.nsaId.append(value)
    def insert_nsaId(self, index, value): self.nsaId[index] = value
    def validate_NsaIdType(self, value):
        # Validate type NsaIdType, a restriction on xsd:anyURI.
        pass
    def get_serviceType(self): return self.serviceType
    def set_serviceType(self, serviceType): self.serviceType = serviceType
    def add_serviceType(self, value): self.serviceType.append(value)
    def insert_serviceType(self, index, value): self.serviceType[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='FilterType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='FilterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='FilterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nsaId_ in self.nsaId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snsaId>%s</%snsaId>%s' % (namespace_, self.gds_format_string(quote_xml(nsaId_).encode(ExternalEncoding), input_name='nsaId'), namespace_, eol_))
        for serviceType_ in self.serviceType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceType>%s</%sserviceType>%s' % (namespace_, self.gds_format_string(quote_xml(serviceType_).encode(ExternalEncoding), input_name='serviceType'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.nsaId or
            self.serviceType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('nsaId=[\n')
        level += 1
        for nsaId_ in self.nsaId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(nsaId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('serviceType=[\n')
        level += 1
        for serviceType_ in self.serviceType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(serviceType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nsaId':
            nsaId_ = child_.text
            nsaId_ = self.gds_validate_string(nsaId_, node, 'nsaId')
            self.nsaId.append(nsaId_)
            self.validate_NsaIdType(self.nsaId)    # validate type NsaIdType
        elif nodeName_ == 'serviceType':
            serviceType_ = child_.text
            serviceType_ = self.gds_validate_string(serviceType_, node, 'serviceType')
            self.serviceType.append(serviceType_)
# end class FilterType


class ServiceExceptionType(GeneratedsSuper):
    """Common service exception used for SOAP faults and Failed message.
    Elements: nsaId - NSA that generated the service exception.
    errorId - Error identifier uniquely identifying each known fault
    within the protocol. text - User friendly message text
    describing the error. variables - A collection of type/value
    pairs providing addition information relating to the error.
    childException - Hierarchical list of service exceptions
    capturing failures within the request tree."""
    subclass = None
    superclass = None
    def __init__(self, nsaId=None, errorId=None, text=None, variables=None, childException=None):
        self.nsaId = nsaId
        self.errorId = errorId
        self.text = text
        self.variables = variables
        if childException is None:
            self.childException = []
        else:
            self.childException = childException
    def factory(*args_, **kwargs_):
        if ServiceExceptionType.subclass:
            return ServiceExceptionType.subclass(*args_, **kwargs_)
        else:
            return ServiceExceptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nsaId(self): return self.nsaId
    def set_nsaId(self, nsaId): self.nsaId = nsaId
    def validate_NsaIdType(self, value):
        # Validate type NsaIdType, a restriction on xsd:anyURI.
        pass
    def get_errorId(self): return self.errorId
    def set_errorId(self, errorId): self.errorId = errorId
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_variables(self): return self.variables
    def set_variables(self, variables): self.variables = variables
    def get_childException(self): return self.childException
    def set_childException(self, childException): self.childException = childException
    def add_childException(self, value): self.childException.append(value)
    def insert_childException(self, index, value): self.childException[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='ServiceExceptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceExceptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='ServiceExceptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='ServiceExceptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nsaId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snsaId>%s</%snsaId>%s' % (namespace_, self.gds_format_string(quote_xml(self.nsaId).encode(ExternalEncoding), input_name='nsaId'), namespace_, eol_))
        if self.errorId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorId>%s</%serrorId>%s' % (namespace_, self.gds_format_string(quote_xml(self.errorId).encode(ExternalEncoding), input_name='errorId'), namespace_, eol_))
        if self.text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stext>%s</%stext>%s' % (namespace_, self.gds_format_string(quote_xml(self.text).encode(ExternalEncoding), input_name='text'), namespace_, eol_))
        if self.variables is not None:
            self.variables.export(outfile, level, namespace_, name_='variables', pretty_print=pretty_print)
        for childException_ in self.childException:
            childException_.export(outfile, level, namespace_, name_='childException', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.nsaId is not None or
            self.errorId is not None or
            self.text is not None or
            self.variables is not None or
            self.childException
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceExceptionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.nsaId is not None:
            showIndent(outfile, level)
            outfile.write('nsaId=%s,\n' % quote_python(self.nsaId).encode(ExternalEncoding))
        if self.errorId is not None:
            showIndent(outfile, level)
            outfile.write('errorId=%s,\n' % quote_python(self.errorId).encode(ExternalEncoding))
        if self.text is not None:
            showIndent(outfile, level)
            outfile.write('text=%s,\n' % quote_python(self.text).encode(ExternalEncoding))
        if self.variables is not None:
            showIndent(outfile, level)
            outfile.write('variables=model_.VariablesType(\n')
            self.variables.exportLiteral(outfile, level, name_='variables')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('childException=[\n')
        level += 1
        for childException_ in self.childException:
            showIndent(outfile, level)
            outfile.write('model_.ServiceExceptionType(\n')
            childException_.exportLiteral(outfile, level, name_='ServiceExceptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nsaId':
            nsaId_ = child_.text
            nsaId_ = self.gds_validate_string(nsaId_, node, 'nsaId')
            self.nsaId = nsaId_
            self.validate_NsaIdType(self.nsaId)    # validate type NsaIdType
        elif nodeName_ == 'errorId':
            errorId_ = child_.text
            errorId_ = self.gds_validate_string(errorId_, node, 'errorId')
            self.errorId = errorId_
        elif nodeName_ == 'text':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'text')
            self.text = text_
        elif nodeName_ == 'variables':
            obj_ = VariablesType.factory()
            obj_.build(child_)
            self.set_variables(obj_)
        elif nodeName_ == 'childException':
            obj_ = ServiceExceptionType.factory()
            obj_.build(child_)
            self.childException.append(obj_)
# end class ServiceExceptionType


class VariablesType(GeneratedsSuper):
    """A specific type definition providing a set of zero or more variables
    associated with the ServiceException."""
    subclass = None
    superclass = None
    def __init__(self, variable=None):
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
    def factory(*args_, **kwargs_):
        if VariablesType.subclass:
            return VariablesType.subclass(*args_, **kwargs_)
        else:
            return VariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def add_variable(self, value): self.variable.append(value)
    def insert_variable(self, index, value): self.variable[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='VariablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='VariablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='VariablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variable_ in self.variable:
            variable_.export(outfile, level, namespace_, name_='variable', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.variable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variable=[\n')
        level += 1
        for variable_ in self.variable:
            showIndent(outfile, level)
            outfile.write('model_.TypeValuePairType(\n')
            variable_.exportLiteral(outfile, level, name_='TypeValuePairType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variable':
            obj_ = TypeValuePairType.factory()
            obj_.build(child_)
            self.variable.append(obj_)
# end class VariablesType


class TypeValuePairListType(GeneratedsSuper):
    """A holder element providing an attribute list definition for the
    type/value pair. Elements: attribute - An instance of a
    type/value pair."""
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if TypeValuePairListType.subclass:
            return TypeValuePairListType.subclass(*args_, **kwargs_)
        else:
            return TypeValuePairListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute(self, index, value): self.attribute[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='TypeValuePairListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeValuePairListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='TypeValuePairListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='TypeValuePairListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TypeValuePairListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.TypeValuePairType(\n')
            attribute_.exportLiteral(outfile, level, name_='TypeValuePairType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = TypeValuePairType.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
# end class TypeValuePairListType


class TypeValuePairType(GeneratedsSuper):
    """Definition for a simple type and multi-value tuple. Includes simple
    string type and value, as well as more advanced extensions if
    needed. A targetNamespace attribute is include to provide
    context where needed. Elements: value - A string value
    corresponding to type. any - Provides a flexible mechanism
    allowing additional elements to be provided as an alternative,
    or in combination with value. Use of this element field is
    beyond the current scope of this NSI specification, but may be
    used in the future to extend the existing protocol without
    requiring a schema change. Attributes: type - A string
    representing the name of the type. targetNamespace - An optional
    URL to qualify the name space of the capability. anyAttribute -
    Provides a flexible mechanism allowing additional attributes
    non-specified to be provided as needed for peer-to-peer NSA
    communications. Use of this attribute field is beyond the
    current scope of this NSI specification, but may be used in the
    future to extend the existing protocol without requiring a
    schema change."""
    subclass = None
    superclass = None
    def __init__(self, targetNamespace=None, type_=None, value=None, anytypeobjs_=None):
        self.targetNamespace = _cast(None, targetNamespace)
        self.type_ = _cast(None, type_)
        if value is None:
            self.value = []
        else:
            self.value = value
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TypeValuePairType.subclass:
            return TypeValuePairType.subclass(*args_, **kwargs_)
        else:
            return TypeValuePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_targetNamespace(self): return self.targetNamespace
    def set_targetNamespace(self, targetNamespace): self.targetNamespace = targetNamespace
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='tns:', name_='TypeValuePairType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeValuePairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='TypeValuePairType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.targetNamespace is not None and 'targetNamespace' not in already_processed:
            already_processed.append('targetNamespace')
            outfile.write(' targetNamespace=%s' % (self.gds_format_string(quote_attrib(self.targetNamespace).encode(ExternalEncoding), input_name='targetNamespace'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='TypeValuePairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.value or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TypeValuePairType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetNamespace is not None and 'targetNamespace' not in already_processed:
            already_processed.append('targetNamespace')
            showIndent(outfile, level)
            outfile.write('targetNamespace = "%s",\n' % (self.targetNamespace,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetNamespace', node)
        if value is not None and 'targetNamespace' not in already_processed:
            already_processed.append('targetNamespace')
            self.targetNamespace = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        else:
            obj_ = self.gds_build_any(child_, 'TypeValuePairType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class TypeValuePairType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'queryNsaRequest'
        rootClass = QueryNsaRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'queryNsaRequest'
        rootClass = QueryNsaRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
#    sys.stdout.write('<?xml version="1.0" ?>\n')
#    rootObj.export(sys.stdout, 0, name_="queryNsaRequest", namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'queryNsaRequest'
        rootClass = QueryNsaRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from discovery import *\n\n')
    sys.stdout.write('import discovery as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CapabilitiesType",
    "FilterType",
    "NsaDiscoveryType",
    "QueryNsaRequestType",
    "QueryNsaResponseType",
    "ServiceExceptionType",
    "ServiceType",
    "ServicesType",
    "TypeValuePairListType",
    "TypeValuePairType",
    "VariablesType",
    "VersionType",
    "VersionsType",
    "discovery"
    ]
