#!/usr/bin/env python

import os
import sys
import socket

from twisted.python import log, usage
from twisted.internet import reactor, defer

from opennsa import setup, nsa
from opennsa.cli import options, parser, commands, logobserver


CLI_DEFAULTS            = '.opennsa-cli'
WSDL_DEFAULT_DIRECTORY  = '/usr/local/share/nsi/wsdl'
REQUESTER_URL_BASE      = 'http://%s:%i/NSI/services/ConnectionService'


def doMain():
    config = parser.Options()
    try:
        config.parseOptions()
    except usage.UsageError, errortext:
        print '%s: %s' % (sys.argv[0], errortext)
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return

    observer = logobserver.SimpleObserver(sys.stdout)
    log.startLoggingWithObserver(observer.emit)

    if config[options.VERBOSE]:
        observer.debug = True

    # read defaults
    defaults_file = config[options.DEFAULTS_FILE] or os.path.join( os.path.expanduser('~'), CLI_DEFAULTS )
    if os.path.exists(defaults_file):
        defaults = options.readDefaults( open(defaults_file) )
    else:
        defaults = {}

    print "Defaults:"
    for k,v in defaults.items():
        print " ", k, ":", v

    wsdl_dir        = config[options.WSDL_DIRECTORY]    or defaults.get(options.WSDL_DIRECTORY) or WSDL_DEFAULT_DIRECTORY
    host            = config[options.HOST]              or defaults.get(options.HOST)           or socket.getfqdn()
    port            = config[options.PORT]              or defaults.get(options.PORT)           or 7080
    requester_url   = REQUESTER_URL_BASE % (host, port)

    print config.subOptions[options.TOPOLOGY_FILE]

    topology_file   = config.subOptions[options.TOPOLOGY_FILE]  or defaults.get(options.TOPOLOGY_FILE)
    network         = config.subOptions[options.NETWORK]        or defaults.get(options.NETWORK)
    service_url     = config.subOptions[options.SERVICE_URL]    or defaults.get(options.SERVICE_URL)

    requester_nsa   = config.subOptions[options.REQUESTER]      or defaults.get(options.REQUESTER)      or 'OpenNSA-CLI'
    provider_nsa    = config.subOptions[options.PROVIDER]       or defaults.get(options.PROVIDER)

    if topology_file and network:
        client_nsa      = nsa.NetworkServiceAgent(requester_nsa, requester_url)

        from opennsa import topology
        topo = topology.parseGOLETopology( open(topology_file) )
        provider_nsa  = topo.getNetwork(network).nsa

    elif service_url:
        client_nsa      = nsa.NetworkServiceAgent(requester_nsa, requester_url)
        provider_nsa    = nsa.NetworkServiceAgent(provider_nsa, service_url)

    else:
        raise usage.UsageError('Neither topology file+network or service URL defined')

    client, service, factory = setup.createClient(host, port, wsdl_dir)
    reactor.listenTCP(port, factory)

    if config.subCommand == 'reserve':
        source_stp = config.subOptions[options.SOURCE_STP]  or defaults.get(options.SOURCE_STP)
        dest_stp   = config.subOptions[options.DEST_STP]    or defaults.get(options.DEST_STP)
        if source_stp is None:
            raise usage.UsageError('Source STP is not defined')
        if dest_stp is None:
            raise usage.UsageError('Dest STP is not defined')
        return commands.reserve(client, client_nsa, provider_nsa, source_stp, dest_stp)

    elif config.subCommand == 'provision':
        return commands.provision(client, client_nsa, connection_id)

    elif config.subCommand == 'release':
        return commands.release(client, client_nsa, provider_nsa, connection_id)

    elif config.subCommand == 'terminate':
        return commands.terminate(client, client_nsa, provider_nsa, connection_id)

    elif config.subCommand == 'querysummary':
        return commands.querysummary(client, client_nsa, provider_nsa)

    elif config.subCommand == 'querydetails':
        return commands.querydetails(client, client_nsa, provider_nsa)

    else:
        print "No subcommand specified"
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return



def main():

    def printError(error):
        if error.type == SystemExit:
            return
        elif error.type == usage.UsageError:
            log.msg("Usage error: " + error.getErrorMessage())
        else:
            #print "Error: %s" % error.value
            log.err(error)

    d = defer.maybeDeferred(doMain)
    d.addErrback(printError)
    d.addBoth(lambda _ : reactor.stop())
    return d


if __name__ == '__main__':
    reactor.callWhenRunning(main)
    reactor.run()

