#!/usr/bin/env python

import os
import sys

from twisted.python import log, usage
from twisted.internet import reactor, defer

from opennsa.cli import parser, commands, defaultsreader, logobserver


CLI_DEFAULTS = '.opennsa-cli'
WSDL_DEFAULT_DIRECTORY = '/usr/local/share/nsi/wsdl'



def doMain():
    config = parser.Options()
    try:
        config.parseOptions()
    except usage.UsageError, errortext:
        print '%s: %s' % (sys.argv[0], errortext)
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return

    observer = logobserver.SimpleObserver(sys.stdout)
    log.startLoggingWithObserver(observer.emit)

    if config['verbose']:
        observer.debug = True

    # read defaults
    defaults_file = config['defaultsfile'] or os.path.join( os.path.expanduser('~'), CLI_DEFAULTS )
    if os.path.exists(defaults_file):
        defaults = defaultsreader.readDefaults( open(defaults_file) )
    else:
        defaults = {}

    print "Defaults:"
    for k,v in defaults.items():
        print " ", k, ":", v

    wsdl_dir = config['wsdldirectory'] or defaults.get('wsdldirectory') or WSDL_DEFAULT_DIRECTORY


    if config.subCommand == 'reserve':
        return commands.reserve(wsdl_dir,
                                config.subOptions['service-url'],
                                config.subOptions['provider'],
                                config.subOptions['requester'],
                                config.subOptions['source-stp'],
                                config.subOptions['dest-stp'])

    elif config.subCommand:
        print 'Unknown command: %s, should not happen' % config.subCommand
        print 'Cowardly bailing out'
        return

    else:
        print "No subcommand specified"
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return



def main():

    def printError(error):
        if error.type == SystemExit:
            return
        #print "Error: %s" % error.value
        log.err(error)

    d = defer.maybeDeferred(doMain)
    d.addErrback(printError)
    d.addBoth(lambda _ : reactor.stop())
    return d


if __name__ == '__main__':
    reactor.callWhenRunning(main)
    reactor.run()

